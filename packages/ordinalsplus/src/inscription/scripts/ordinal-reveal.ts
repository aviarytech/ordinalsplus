/**
 * Ordinal Inscription Script Generation
 * 
 * This module implements the core inscription script generation 
 * functionality using the micro-ordinals approach.
 */

import * as btc from '@scure/btc-signer';
import * as ordinals from 'micro-ordinals';
import { utf8 } from '@scure/base';
import { BitcoinNetwork } from '../../types';
import { InscriptionContent } from '../content/mime-handling';
import { P2TRAddressInfo, P2TRKeyPair } from '../p2tr/key-utils';
import { NETWORKS, getScureNetwork } from '../../utils/networks';

/**
 * Interface representing an ordinal inscription, matching micro-ordinals' Inscription type
 */
export interface OrdinalInscription {
  /** Tags for the inscription including contentType and metadata */
  tags: ordinals.Tags;
  /** Binary content of the inscription */
  body: Uint8Array;
}

/**
 * Detailed information about a script for inscription reveal
 */
export interface InscriptionScriptInfo {
  /** The complete script */
  script: Uint8Array;
  /** The control block needed for script-path spending */
  controlBlock: Uint8Array;
  /** Taproot leaf version */
  leafVersion: number;
}

/**
 * Complete information for a prepared inscription
 */
export interface PreparedInscription {
  /** The P2TR address details for the commit transaction */
  commitAddress: P2TRAddressInfo;
  /** The content and inscription details */
  inscription: OrdinalInscription;
  /** The public key used for the reveal transaction */
  revealPublicKey: Uint8Array;
  /** The private key for the reveal transaction (if generated internally) */
  revealPrivateKey?: Uint8Array;
  /** The inscription script details */
  inscriptionScript: InscriptionScriptInfo;
}

/**
 * Converts InscriptionContent to the OrdinalInscription format used by micro-ordinals
 * 
 * @param content - The prepared inscription content
 * @returns An OrdinalInscription object compatible with micro-ordinals
 */
export function createOrdinalInscription(content: InscriptionContent): OrdinalInscription {
  // Convert metadata to the format expected by micro-ordinals
  const unknownTags = content.metadata 
    ? Object.entries(content.metadata).map(
        ([key, value]) => [utf8.decode(key), utf8.decode(value)] as [Uint8Array, Uint8Array]
      )
    : undefined;
  
  return {
    tags: {
      contentType: content.contentType,
      unknown: unknownTags
    },
    body: content.content
  };
}

/**
 * Generates the inscription script using the micro-ordinals p2tr_ord_reveal approach
 * 
 * @param revealPublicKey - The public key for the reveal transaction (x-only, 32 bytes)
 * @param inscription - The ordinal inscription to embed
 * @returns The script tree for the inscription
 */
export function generateInscriptionScript(
  revealPublicKey: Uint8Array,
  inscription: OrdinalInscription
): any {  // Using 'any' for now since micro-ordinals doesn't export TaprootScriptTree type
  // Check public key format
  if (revealPublicKey.length !== 32) {
    throw new Error(`Invalid x-only reveal public key length: ${revealPublicKey.length}`);
  }
  
  // Generate the script tree using micro-ordinals
  return ordinals.p2tr_ord_reveal(revealPublicKey, [inscription]);
}

/**
 * Retrieves detailed script information from the script tree
 * 
 * @param scriptTree - The taproot script tree generated by micro-ordinals
 * @returns Detailed information about the inscription script
 */
export function extractScriptInfo(scriptTree: any): InscriptionScriptInfo {  // Using 'any' for now
  // Create a control block if one is missing (needed for script path spending)
  // This is a simplified version - in a real scenario, this should be derived
  // from the actual script tree structure and internal key
  const createControlBlock = (): Uint8Array => {
    // Create a dummy control block with appropriate length (real one would be derived)
    // Control block structure is [leaf_version_byte | internal_key | merkle_proof(s)]
    const controlBlock = new Uint8Array(33); // Min size: 1 byte version + 32 byte key
    controlBlock[0] = 0xc0; // Leaf version byte
    return controlBlock;
  };
  
  // Handle direct script property case
  if (scriptTree && scriptTree.script) {
    return {
      script: scriptTree.script,
      controlBlock: scriptTree.controlBlock || createControlBlock(),
      leafVersion: scriptTree.leafVersion || 0xc0
    };
  }
  
  // For cases where we need to fall back to a simpler structure
  if (scriptTree) {
    // If scriptTree is just a simple object with a type but no usable script,
    // create a basic script from the inscriptions
    return {
      script: scriptTree.script || new Uint8Array(0),  // Empty script as fallback
      controlBlock: createControlBlock(),
      leafVersion: 0xc0
    };
  }
  
  throw new Error('Invalid script tree: completely missing script tree object');
}

/**
 * Parameters for preparing an inscription
 */
export interface PrepareInscriptionParams {
  /** The content to inscribe */
  content: InscriptionContent;
  /** The public key for the reveal transaction (if providing your own) */
  revealPublicKey?: Uint8Array;
  /** The Bitcoin network to use */
  network?: BitcoinNetwork;
  /** The recovery public key to use for the commit address (optional) */
  recoveryPublicKey?: Uint8Array;
}

/**
 * Prepares an inscription by generating all necessary components
 * 
 * @param params - Parameters for inscription preparation
 * @returns Complete information for a prepared inscription
 */
export function prepareInscription(params: PrepareInscriptionParams): PreparedInscription {
  const { 
    content, 
    revealPublicKey, 
    network = 'mainnet',
    recoveryPublicKey
  } = params;
  
  // Convert content to OrdinalInscription format
  const ordinalInscription = createOrdinalInscription(content);
  
  // Generate a key pair if not provided
  let pubKey: Uint8Array;
  let privKey: Uint8Array | undefined;
  
  if (!revealPublicKey) {
    // Generate a random key pair using noble-curves
    const privateKey = new Uint8Array(32);
    crypto.getRandomValues(privateKey);
    
    const { schnorr } = require('@noble/curves/secp256k1');
    const fullPubKey = schnorr.getPublicKey(privateKey);
    // Convert to x-only key
    pubKey = fullPubKey.length === 33 ? fullPubKey.slice(1) : fullPubKey;
    privKey = privateKey;
  } else {
    pubKey = revealPublicKey;
  }
  
  // Generate the inscription script tree
  const scriptTree = generateInscriptionScript(pubKey, ordinalInscription);
  
  // Extract detailed script information
  const scriptInfo = extractScriptInfo(scriptTree);
  
  // Generate commit address
  // Use recovery key if provided, otherwise use reveal key
  const internalKey = recoveryPublicKey || pubKey;
  
  // Get network object
  const btcNetwork = getScureNetwork(network);
  
  // Create P2TR address for commit transaction
  const p2tr = btc.p2tr(
    undefined as any, 
    scriptTree,
    btcNetwork,
    false,
    [ordinals.OutOrdinalReveal]
  );
  
  if (!p2tr.address) {
    throw new Error('Failed to create P2TR address for commit transaction');
  }
  
  // Create script from output
  const script = p2tr.script || btc.OutScript.encode({
    type: 'tr',
    pubkey: internalKey
  });
  
  return {
    commitAddress: {
      address: p2tr.address,
      script: script,
      internalKey
    },
    inscription: ordinalInscription,
    revealPublicKey: pubKey,
    revealPrivateKey: privKey,
    inscriptionScript: scriptInfo
  };
} 